/* eslint-disable class-methods-use-this */

import {
  BaseCommand,
  CommandVerifyContext,
  CommandExecuteContext,
  VerificationResult,
  VerifyStatus,
} from 'lisk-sdk';
import { UserStore } from '../stores/user';
import { UserAccountStore } from '../stores/userAccount';
import { createCommandParamsSchema } from '../schemas';
import { CreateCommandParams, User } from '../types';
import { getNodeForName, verifyHash } from '../utils';

export class CreateCommand extends BaseCommand {
  public schema = createCommandParamsSchema;

  // eslint-disable-next-line @typescript-eslint/require-await
  public async verify(context: CommandVerifyContext<CreateCommandParams>): Promise<VerificationResult> {
    const { params, transaction } = context;
    // The name and nick name should not be the same
    if (params.name === params.nickName) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error('The name and nick name should not be the same'),
      };
    }
    // Validate the signature of the avatar hash
    const isAvatarHashGenuine = verifyHash(params.avatarSignature, params.avatarHash, transaction.senderPublicKey);
    if (!isAvatarHashGenuine) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error('The avatar signature is not generated by the sender'),
      };
    }
    // Validate the signature of the banner hash
    const isBannerHashGenuine = verifyHash(params.bannerSignature, params.bannerHash, transaction.senderPublicKey);
    if (!isBannerHashGenuine) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error('The banner signature is not generated by the sender'),
      };
    }
    return { status: VerifyStatus.OK };
  }

  public async execute(context: CommandExecuteContext<CreateCommandParams>): Promise<void> {
    const { params, transaction } = context;

    const userAccountStore = this.stores.get(UserAccountStore);
    const userStore = this.stores.get(UserStore);

    // The name should not be already registered
    const userAccountExists = await userAccountStore.has(context, transaction.senderAddress);
    if (userAccountExists) {
      throw new Error('You have already created a user for this account.');
    }

    // Get namehash output of the user NFT
    const key = getNodeForName(params);

    // Create the user account object
    const userObject: User = {
      ...params,
      creatorAddress: transaction.senderAddress,
    };
    // Save the user account object in account store
    await userAccountStore.set(context, transaction.senderAddress, {
      userID: key,
    });
    // Save the user object in user store
    await userStore.set(context, key, userObject);
  }
}
