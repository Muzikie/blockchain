/* eslint-disable @typescript-eslint/member-ordering */
/* eslint-disable class-methods-use-this */
import {
  BaseCommand,
  CommandVerifyContext,
  CommandExecuteContext,
  VerificationResult,
  VerifyStatus,
} from 'lisk-sdk';
import { BadgeStore } from '../stores/badge';
import { BadgeAccountStore } from '../stores/badgeAccount';
import { CreateCommandParams, Badge, BadgeAccount } from '../types';
import { createCommandParamsSchema } from '../schemas';
import { VALID_GENRES, MIN_RELEASE_YEAR, DEV_ADDRESS } from '../constants';
import { getEntityID, verifyHash } from '../../../utils';
import { BadgeCreated } from '../events/badgeCreated';

export class CreateCommand extends BaseCommand {
  public schema = createCommandParamsSchema;

  // eslint-disable-next-line @typescript-eslint/require-await
  public async verify(
    context: CommandVerifyContext<CreateCommandParams>,
  ): Promise<VerificationResult> {
    const { params, transaction } = context;

    if (!context.transaction.senderAddress.equals(DEV_ADDRESS)) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error('You are not authorized to create a anchor.'),
      };
    }

    const thisYear = new Date().getFullYear();
    const numericYear = Number(params.releaseYear);
    if (numericYear < MIN_RELEASE_YEAR || numericYear > thisYear) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error(
          `Release year must be a number between ${MIN_RELEASE_YEAR} and ${thisYear}`,
        ),
      };
    }
    if (params.genre.some(item => item > VALID_GENRES.length)) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error('Genres should be selected from the list of valid genres'),
      };
    }
    if (
      params.owners.length === 0 ||
      params.owners.some(item => item.shares < 1) ||
      params.owners.reduce((acc, item) => acc + item.shares, 0) !== 100
    ) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error(
          'Owners should have a total of 100 shares. Each owner should have a positive number of shares.',
        ),
      };
    }

    const isHashGenuine = verifyHash(params.badgeSignature, params.badgeHash, transaction.senderPublicKey);
    if (!isHashGenuine) {
      return {
        status: VerifyStatus.FAIL,
        error: new Error('The hash signature is not generated by the sender'),
      };
    }

    return { status: VerifyStatus.OK };
  }

  public async execute(context: CommandExecuteContext<CreateCommandParams>): Promise<void> {
    const { params, transaction } = context;
    // Get namehash output of the badge file
    const badgeID = getEntityID(context.transaction);

    const badgeAccountSubStore = this.stores.get(BadgeAccountStore);
    const badgeSubStore = this.stores.get(BadgeStore);

    // Check uniqueness of the NFT
    const badgeExists = await badgeSubStore.has(context, badgeID);
    if (badgeExists) {
      throw new Error('You have already created this badge.');
    }

    // Create the Badge object and save it on the blockchain
    const owners = params.owners.map(owner => ({
      address: owner.address,
      shares: owner.shares,
      income: BigInt(0),
    }));

    const badgeObject: Badge = {
      ...params,
      owners,
      creatorAddress: transaction.senderAddress,
    };

    // Store the hash of the badge object in the sender account
    const accountExists = await badgeAccountSubStore.has(context, transaction.senderAddress);
    if (accountExists) {
      const senderAccount: BadgeAccount = await badgeAccountSubStore.get(
        context,
        transaction.senderAddress,
      );
      senderAccount.badge.badges = [...senderAccount.badge.badges, badgeID];
      await badgeAccountSubStore.set(context, transaction.senderAddress, senderAccount);
    } else {
      await badgeAccountSubStore.set(context, context.transaction.senderAddress, {
        badge: {
          badges: [badgeID],
        },
      });
    }

    // @todo Here we should check if the Badge is already uploaded using steganography methods
    // Store the badge object in the blockchain
    await badgeSubStore.set(context, badgeID, badgeObject);

    // Emit a "New collection" event
    const badgeCreated = this.events.get(BadgeCreated);
    badgeCreated.add(context, {
      creatorAddress: context.transaction.senderAddress,
      badgeID,
    }, [context.transaction.senderAddress]);
  }
}
